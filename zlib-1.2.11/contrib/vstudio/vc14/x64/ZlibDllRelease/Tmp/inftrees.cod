; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN186
	DD	imagerel $LN186+378
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN186+378
	DD	imagerel $LN186+1162
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN186+1162
	DD	imagerel $LN186+1180
	DD	imagerel $chain$1$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 021H
	DD	imagerel $LN186
	DD	imagerel $LN186+378
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020521H
	DD	0fc405H
	DD	imagerel $LN186
	DD	imagerel $LN186+378
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082201H
	DD	0f018f222H
	DD	0d014e016H
	DD	060117012H
	DD	0500f3010H
; Function compile flags: /Ogtpy
; File c:\users\lenovo\downloads\zlib-1.2.11\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
match$1$ = 0
sym$2$ = 4
drop$1$ = 8
root$3$ = 12
mask$1$ = 16
extra$1$ = 24
base$1$ = 32
count$ = 40
offs$ = 72
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN186:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00022	45 33 ed	 xor	 r13d, r13d
  00025	45 8b d8	 mov	 r11d, r8d
  00028	41 0f b7 c5	 movzx	 eax, r13w
  0002c	8b d9		 mov	 ebx, ecx
  0002e	48 8d 7d a8	 lea	 rdi, QWORD PTR count$[rbp-128]
  00032	b9 10 00 00 00	 mov	 ecx, 16
  00037	4d 8b f1	 mov	 r14, r9
  0003a	48 8b f2	 mov	 rsi, rdx
  0003d	66 f3 ab	 rep stosw

; 109  :     for (sym = 0; sym < codes; sym++)

  00040	45 85 c0	 test	 r8d, r8d
  00043	74 1d		 je	 SHORT $LN6@inflate_ta
  00045	48 8b fa	 mov	 rdi, rdx
  00048	45 8b c3	 mov	 r8d, r11d
  0004b	0f 1f 44 00 00	 npad	 5
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00050	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  00053	48 8d 7f 02	 lea	 rdi, QWORD PTR [rdi+2]
  00057	66 ff 44 45 a8	 inc	 WORD PTR count$[rbp+rax*2-128]
  0005c	49 83 e8 01	 sub	 r8, 1
  00060	75 ee		 jne	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00062	48 8b 7d 60	 mov	 rdi, QWORD PTR bits$[rbp-128]
  00066	ba 0d 00 00 00	 mov	 edx, 13

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0006b	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00071	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]
  00074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00080	41 8b c0	 mov	 eax, r8d
  00083	41 83 cf ff	 or	 r15d, -1		; ffffffffH
  00087	66 44 39 6c 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  0008d	75 4f		 jne	 SHORT $LN78@inflate_ta
  0008f	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00092	66 44 39 6c 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  00098	75 41		 jne	 SHORT $LN130@inflate_ta
  0009a	8b c2		 mov	 eax, edx
  0009c	66 44 39 6c 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  000a2	75 31		 jne	 SHORT $LN131@inflate_ta
  000a4	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000a7	66 44 39 6c 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  000ad	75 20		 jne	 SHORT $LN132@inflate_ta
  000af	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000b2	66 44 39 6c 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  000b8	75 0f		 jne	 SHORT $LN133@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000ba	41 83 c0 fb	 add	 r8d, -5			; fffffffbH
  000be	83 c2 fb	 add	 edx, -5			; fffffffbH
  000c1	41 83 f8 01	 cmp	 r8d, 1
  000c5	73 b9		 jae	 SHORT $LL10@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000c7	eb 15		 jmp	 SHORT $LN78@inflate_ta
$LN133@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000c9	41 83 c0 fc	 add	 r8d, -4			; fffffffcH
  000cd	eb 0f		 jmp	 SHORT $LN78@inflate_ta
$LN132@inflate_ta:
  000cf	41 83 c0 fd	 add	 r8d, -3			; fffffffdH

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000d3	eb 09		 jmp	 SHORT $LN78@inflate_ta
$LN131@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000d5	41 83 c0 fe	 add	 r8d, -2			; fffffffeH

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000d9	eb 03		 jmp	 SHORT $LN78@inflate_ta
$LN130@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000db	45 03 c7	 add	 r8d, r15d
$LN78@inflate_ta:

; 116  :     if (root > max) root = max;

  000de	45 3b c8	 cmp	 r9d, r8d
  000e1	45 0f 47 c8	 cmova	 r9d, r8d

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000e5	45 85 c0	 test	 r8d, r8d
  000e8	75 29		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000ea	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000ed	c7 45 50 40 01
	00 00		 mov	 DWORD PTR here$[rbp-128], 320 ; 00000140H
  000f4	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  000f7	89 01		 mov	 DWORD PTR [rcx], eax
  000f9	49 83 06 04	 add	 QWORD PTR [r14], 4
  000fd	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00100	89 01		 mov	 DWORD PTR [rcx], eax
  00102	49 83 06 04	 add	 QWORD PTR [r14], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00106	33 c0		 xor	 eax, eax
  00108	c7 07 01 00 00
	00		 mov	 DWORD PTR [rdi], 1
  0010e	e9 77 03 00 00	 jmp	 $LN1@inflate_ta
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00113	41 ba 01 00 00
	00		 mov	 r10d, 1
  00119	45 3b c2	 cmp	 r8d, r10d
  0011c	76 16		 jbe	 SHORT $LN172@inflate_ta
  0011e	48 8d 45 aa	 lea	 rax, QWORD PTR count$[rbp-126]
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  00122	66 44 39 28	 cmp	 WORD PTR [rax], r13w
  00126	75 0c		 jne	 SHORT $LN172@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00128	41 ff c2	 inc	 r10d
  0012b	48 83 c0 02	 add	 rax, 2
  0012f	45 3b d0	 cmp	 r10d, r8d
  00132	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN172@inflate_ta:

; 128  :     if (root < min) root = min;

  00134	45 3b ca	 cmp	 r9d, r10d

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00137	bf 01 00 00 00	 mov	 edi, 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  0013c	8b d7		 mov	 edx, edi
  0013e	45 0f 42 ca	 cmovb	 r9d, r10d
  00142	44 89 4d 8c	 mov	 DWORD PTR root$3$[rbp-128], r9d
  00146	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00150	8b c2		 mov	 eax, edx
  00152	03 ff		 add	 edi, edi
  00154	0f b7 4c 45 a8	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  00159	2b f9		 sub	 edi, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0015b	78 15		 js	 SHORT $LN42@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  0015d	ff c2		 inc	 edx
  0015f	83 fa 0f	 cmp	 edx, 15
  00162	76 ec		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  00164	85 ff		 test	 edi, edi
  00166	7e 12		 jle	 SHORT $LN41@inflate_ta
  00168	85 db		 test	 ebx, ebx
  0016a	74 06		 je	 SHORT $LN42@inflate_ta
  0016c	41 83 f8 01	 cmp	 r8d, 1
  00170	74 08		 je	 SHORT $LN41@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00172	83 c8 ff	 or	 eax, -1
  00175	e9 10 03 00 00	 jmp	 $LN1@inflate_ta
$LN41@inflate_ta:
  0017a	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;
; 142  :     for (len = 1; len < MAXBITS; len++)

  0017f	49 8b cd	 mov	 rcx, r13
  00182	66 44 89 6d ca	 mov	 WORD PTR offs$[rbp-126], r13w
  00187	ba 0e 00 00 00	 mov	 edx, 14
  0018c	0f 1f 40 00	 npad	 4
$LL19@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00190	0f b7 44 0d aa	 movzx	 eax, WORD PTR count$[rbp+rcx-126]
  00195	66 03 44 0d ca	 add	 ax, WORD PTR offs$[rbp+rcx-126]
  0019a	66 89 44 0d cc	 mov	 WORD PTR offs$[rbp+rcx-124], ax
  0019f	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  001a3	48 83 ea 01	 sub	 rdx, 1
  001a7	75 e7		 jne	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001a9	41 8b fd	 mov	 edi, r13d
  001ac	45 85 db	 test	 r11d, r11d
  001af	74 33		 je	 SHORT $LN21@inflate_ta
  001b1	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
  001b5	48 8b d6	 mov	 rdx, rsi
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001b8	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001bb	66 85 c0	 test	 ax, ax
  001be	74 15		 je	 SHORT $LN20@inflate_ta
  001c0	0f b7 c0	 movzx	 eax, ax
  001c3	0f b7 4c 45 c8	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-128]
  001c8	66 41 89 3c 49	 mov	 WORD PTR [r9+rcx*2], di
  001cd	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001d0	66 ff 44 45 c8	 inc	 WORD PTR offs$[rbp+rax*2-128]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001d5	ff c7		 inc	 edi
  001d7	48 83 c2 02	 add	 rdx, 2
  001db	41 3b fb	 cmp	 edi, r11d
  001de	72 d8		 jb	 SHORT $LL22@inflate_ta
  001e0	44 8b 4d 8c	 mov	 r9d, DWORD PTR root$3$[rbp-128]
$LN21@inflate_ta:

; 193  :         extra = dext;
; 194  :         match = 0;

  001e4	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  001e8	85 db		 test	 ebx, ebx
  001ea	74 3d		 je	 SHORT $LN44@inflate_ta

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  001ec	83 fb 01	 cmp	 ebx, 1
  001ef	74 1b		 je	 SHORT $LN45@inflate_ta

; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  001f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 193  :         extra = dext;
; 194  :         match = 0;

  001f8	41 8b d5	 mov	 edx, r13d
  001fb	48 89 45 a0	 mov	 QWORD PTR base$1$[rbp-128], rax
  001ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  00206	48 89 45 98	 mov	 QWORD PTR extra$1$[rbp-128], rax
  0020a	eb 2a		 jmp	 SHORT $LN181@inflate_ta
$LN45@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;

  0020c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;
; 189  :         match = 257;

  00213	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00218	48 89 45 a0	 mov	 QWORD PTR base$1$[rbp-128], rax
  0021c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  00223	48 89 45 98	 mov	 QWORD PTR extra$1$[rbp-128], rax

; 190  :         break;

  00227	eb 0d		 jmp	 SHORT $LN181@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00229	48 89 7d 98	 mov	 QWORD PTR extra$1$[rbp-128], rdi

; 184  :         match = 20;

  0022d	ba 14 00 00 00	 mov	 edx, 20
  00232	48 89 7d a0	 mov	 QWORD PTR base$1$[rbp-128], rdi
$LN181@inflate_ta:

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */

  00236	4d 8b 26	 mov	 r12, QWORD PTR [r14]

; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */

  00239	41 8b dd	 mov	 ebx, r13d

; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */
; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0023c	44 8b 75 40	 mov	 r14d, DWORD PTR type$[rbp-128]
  00240	41 8b c9	 mov	 ecx, r9d
  00243	be 01 00 00 00	 mov	 esi, 1
  00248	44 89 6d 84	 mov	 DWORD PTR sym$2$[rbp-128], r13d
  0024c	d3 e6		 shl	 esi, cl
  0024e	45 8b dd	 mov	 r11d, r13d
  00251	89 55 80	 mov	 DWORD PTR match$1$[rbp-128], edx
  00254	44 8b ee	 mov	 r13d, esi
  00257	89 5d 88	 mov	 DWORD PTR drop$1$[rbp-128], ebx
  0025a	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  0025d	89 45 90	 mov	 DWORD PTR mask$1$[rbp-128], eax
  00260	41 83 fe 01	 cmp	 r14d, 1
  00264	75 08		 jne	 SHORT $LN49@inflate_ta
  00266	81 fe 54 03 00
	00		 cmp	 esi, 852		; 00000354H
  0026c	eb 0c		 jmp	 SHORT $LN184@inflate_ta
$LN49@inflate_ta:
  0026e	41 83 fe 02	 cmp	 r14d, 2
  00272	75 0c		 jne	 SHORT $LN168@inflate_ta
  00274	81 fe 50 02 00
	00		 cmp	 esi, 592		; 00000250H
$LN184@inflate_ta:
  0027a	0f 87 00 02 00
	00		 ja	 $LN62@inflate_ta
$LN168@inflate_ta:
  00280	8b cb		 mov	 ecx, ebx
  00282	eb 1c		 jmp	 SHORT $LL25@inflate_ta
  00284	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL174@inflate_ta:
  00290	8b 5d 88	 mov	 ebx, DWORD PTR drop$1$[rbp-128]
  00293	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL25@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  002a0	41 0f b6 c2	 movzx	 eax, r10b
  002a4	2a c3		 sub	 al, bl
  002a6	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 217  :         if (work[sym] + 1U < match) {

  002a9	8b c1		 mov	 eax, ecx
  002ab	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  002af	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  002b2	3b c2		 cmp	 eax, edx
  002b4	73 0a		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  002b6	c6 45 50 00	 mov	 BYTE PTR here$[rbp-128], 0

; 219  :             here.val = work[sym];

  002ba	66 89 4d 52	 mov	 WORD PTR here$[rbp-126], cx

; 220  :         }

  002be	eb 28		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  002c0	3b ca		 cmp	 ecx, edx
  002c2	72 1a		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  002c4	48 8b 45 98	 mov	 rax, QWORD PTR extra$1$[rbp-128]
  002c8	2b ca		 sub	 ecx, edx
  002ca	48 03 c9	 add	 rcx, rcx
  002cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d1	88 45 50	 mov	 BYTE PTR here$[rbp-128], al

; 223  :             here.val = base[work[sym] - match];

  002d4	48 8b 45 a0	 mov	 rax, QWORD PTR base$1$[rbp-128]
  002d8	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 224  :         }

  002dc	eb 06		 jmp	 SHORT $LN182@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  002de	c6 45 50 60	 mov	 BYTE PTR here$[rbp-128], 96 ; 00000060H

; 227  :             here.val = 0;

  002e2	33 c0		 xor	 eax, eax
$LN182@inflate_ta:
  002e4	66 89 45 52	 mov	 WORD PTR here$[rbp-126], ax
$LN53@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  002e8	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  002eb	41 8b ca	 mov	 ecx, r10d
  002ee	2b cb		 sub	 ecx, ebx

; 232  :         fill = 1U << curr;

  002f0	8b fe		 mov	 edi, esi
  002f2	41 b9 01 00 00
	00		 mov	 r9d, 1
  002f8	41 8b d3	 mov	 edx, r11d
  002fb	41 d3 e1	 shl	 r9d, cl
  002fe	8b cb		 mov	 ecx, ebx
  00300	d3 ea		 shr	 edx, cl
  00302	03 d6		 add	 edx, esi
$LL30@inflate_ta:

; 233  :         min = fill;                 /* save offset to next table */
; 234  :         do {
; 235  :             fill -= incr;

  00304	41 2b d1	 sub	 edx, r9d

; 236  :             next[(huff >> drop) + fill] = here;

  00307	41 89 04 94	 mov	 DWORD PTR [r12+rdx*4], eax
  0030b	41 2b f9	 sub	 edi, r9d

; 237  :         } while (fill != 0);

  0030e	75 f4		 jne	 SHORT $LL30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  00310	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00314	ba 01 00 00 00	 mov	 edx, 1
  00319	d3 e2		 shl	 edx, cl

; 241  :         while (huff & incr)

  0031b	41 85 d3	 test	 edx, r11d
  0031e	74 07		 je	 SHORT $LN32@inflate_ta
$LL31@inflate_ta:

; 242  :             incr >>= 1;

  00320	d1 ea		 shr	 edx, 1
  00322	41 85 d3	 test	 edx, r11d
  00325	75 f9		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00327	85 d2		 test	 edx, edx
  00329	74 0d		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0032b	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0032e	44 23 d8	 and	 r11d, eax

; 245  :             huff += incr;

  00331	44 03 da	 add	 r11d, edx

; 246  :         }

  00334	33 d2		 xor	 edx, edx
  00336	eb 05		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  00338	33 d2		 xor	 edx, edx
  0033a	44 8b da	 mov	 r11d, edx
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  0033d	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]

; 252  :         if (--(count[len]) == 0) {

  00340	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  00345	ff c1		 inc	 ecx
  00347	41 8b c2	 mov	 eax, r10d
  0034a	89 4d 84	 mov	 DWORD PTR sym$2$[rbp-128], ecx
  0034d	66 01 7c 45 a8	 add	 WORD PTR count$[rbp+rax*2-128], di
  00352	75 1f		 jne	 SHORT $LN175@inflate_ta

; 253  :             if (len == max) break;

  00354	45 3b d0	 cmp	 r10d, r8d
  00357	0f 84 ea 00 00
	00		 je	 $LN82@inflate_ta

; 254  :             len = lens[work[sym]];

  0035d	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  00361	48 8b 45 48	 mov	 rax, QWORD PTR lens$[rbp-128]
  00365	0f b7 0c 4f	 movzx	 ecx, WORD PTR [rdi+rcx*2]
  00369	44 0f b7 14 48	 movzx	 r10d, WORD PTR [rax+rcx*2]
  0036e	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  00371	eb 04		 jmp	 SHORT $LN56@inflate_ta
$LN175@inflate_ta:
  00373	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  00377	44 8b 4d 8c	 mov	 r9d, DWORD PTR root$3$[rbp-128]
  0037b	8b 55 80	 mov	 edx, DWORD PTR match$1$[rbp-128]
  0037e	45 3b d1	 cmp	 r10d, r9d
  00381	0f 86 19 ff ff
	ff		 jbe	 $LL25@inflate_ta
  00387	8b 5d 90	 mov	 ebx, DWORD PTR mask$1$[rbp-128]
  0038a	41 23 db	 and	 ebx, r11d
  0038d	41 3b df	 cmp	 ebx, r15d
  00390	0f 84 fa fe ff
	ff		 je	 $LL174@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  00396	8b 7d 88	 mov	 edi, DWORD PTR drop$1$[rbp-128]

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  00399	4d 8d 24 b4	 lea	 r12, QWORD PTR [r12+rsi*4]
  0039d	85 ff		 test	 edi, edi

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;
; 268  :             left = (int)(1 << curr);

  0039f	ba 01 00 00 00	 mov	 edx, 1
  003a4	41 0f 44 f9	 cmove	 edi, r9d
  003a8	45 8b ca	 mov	 r9d, r10d
  003ab	44 2b cf	 sub	 r9d, edi
  003ae	89 7d 88	 mov	 DWORD PTR drop$1$[rbp-128], edi
  003b1	41 8b c9	 mov	 ecx, r9d

; 269  :             while (curr + drop < max) {

  003b4	41 03 f9	 add	 edi, r9d
  003b7	d3 e2		 shl	 edx, cl
  003b9	41 3b f8	 cmp	 edi, r8d
  003bc	73 19		 jae	 SHORT $LN173@inflate_ta
  003be	66 90		 npad	 2
$LL33@inflate_ta:

; 270  :                 left -= count[curr + drop];

  003c0	0f b7 4c 7d a8	 movzx	 ecx, WORD PTR count$[rbp+rdi*2-128]
  003c5	2b d1		 sub	 edx, ecx

; 271  :                 if (left <= 0) break;

  003c7	85 d2		 test	 edx, edx
  003c9	7e 0c		 jle	 SHORT $LN173@inflate_ta

; 272  :                 curr++;

  003cb	41 ff c1	 inc	 r9d
  003ce	ff c7		 inc	 edi

; 273  :                 left <<= 1;

  003d0	03 d2		 add	 edx, edx
  003d2	41 3b f8	 cmp	 edi, r8d
  003d5	72 e9		 jb	 SHORT $LL33@inflate_ta
$LN173@inflate_ta:

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;
; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  003d7	44 8b 75 40	 mov	 r14d, DWORD PTR type$[rbp-128]
  003db	41 8b c9	 mov	 ecx, r9d
  003de	be 01 00 00 00	 mov	 esi, 1
  003e3	d3 e6		 shl	 esi, cl
  003e5	44 03 ee	 add	 r13d, esi
  003e8	41 83 fe 01	 cmp	 r14d, 1
  003ec	75 09		 jne	 SHORT $LN63@inflate_ta
  003ee	41 81 fd 54 03
	00 00		 cmp	 r13d, 852		; 00000354H
  003f5	eb 0d		 jmp	 SHORT $LN183@inflate_ta
$LN63@inflate_ta:
  003f7	41 83 fe 02	 cmp	 r14d, 2
  003fb	75 09		 jne	 SHORT $LN61@inflate_ta
  003fd	41 81 fd 50 02
	00 00		 cmp	 r13d, 592		; 00000250H
$LN183@inflate_ta:
  00404	77 7a		 ja	 SHORT $LN62@inflate_ta
$LN61@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;
; 284  :             (*table)[low].op = (unsigned char)curr;

  00406	48 8b 7d 58	 mov	 rdi, QWORD PTR table$[rbp-128]
  0040a	48 8d 14 9d 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*4]

; 285  :             (*table)[low].bits = (unsigned char)root;

  00412	8b 4d 8c	 mov	 ecx, DWORD PTR root$3$[rbp-128]
  00415	44 8b fb	 mov	 r15d, ebx
  00418	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0041b	44 88 0c 02	 mov	 BYTE PTR [rdx+rax], r9b
  0041f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00422	88 4c 10 01	 mov	 BYTE PTR [rax+rdx+1], cl

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  00426	49 8b c4	 mov	 rax, r12
  00429	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]

; 287  :         }
; 288  :     }

  0042c	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  00430	48 2b c1	 sub	 rax, rcx
  00433	48 c1 f8 02	 sar	 rax, 2
  00437	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax
  0043c	8b 55 80	 mov	 edx, DWORD PTR match$1$[rbp-128]
  0043f	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  00442	e9 49 fe ff ff	 jmp	 $LL174@inflate_ta
$LN82@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  00447	45 85 db	 test	 r11d, r11d
  0044a	74 19		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */
; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;
; 297  :         next[huff] = here;

  0044c	41 8b cb	 mov	 ecx, r11d
  0044f	44 2a d3	 sub	 r10b, bl
  00452	c6 45 50 40	 mov	 BYTE PTR here$[rbp-128], 64 ; 00000040H
  00456	44 88 55 51	 mov	 BYTE PTR here$[rbp-127], r10b
  0045a	66 89 55 52	 mov	 WORD PTR here$[rbp-126], dx
  0045e	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00461	41 89 04 8c	 mov	 DWORD PTR [r12+rcx*4], eax
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  00465	48 8b 4d 58	 mov	 rcx, QWORD PTR table$[rbp-128]
  00469	41 8b c5	 mov	 eax, r13d
  0046c	48 c1 e0 02	 shl	 rax, 2
  00470	48 01 01	 add	 QWORD PTR [rcx], rax

; 302  :     *bits = root;

  00473	8b 45 8c	 mov	 eax, DWORD PTR root$3$[rbp-128]
  00476	48 8b 4d 60	 mov	 rcx, QWORD PTR bits$[rbp-128]
  0047a	89 01		 mov	 DWORD PTR [rcx], eax

; 303  :     return 0;

  0047c	33 c0		 xor	 eax, eax
  0047e	eb 05		 jmp	 SHORT $LN180@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  00480	b8 01 00 00 00	 mov	 eax, 1
$LN180@inflate_ta:
  00485	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
$LN1@inflate_ta:

; 304  : }

  0048a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00491	41 5f		 pop	 r15
  00493	41 5e		 pop	 r14
  00495	41 5d		 pop	 r13
  00497	5f		 pop	 rdi
  00498	5e		 pop	 rsi
  00499	5b		 pop	 rbx
  0049a	5d		 pop	 rbp
  0049b	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
