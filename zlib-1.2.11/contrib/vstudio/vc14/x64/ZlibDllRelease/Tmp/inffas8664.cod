; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	inffas8664fnc:PROC
PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN23
	DD	imagerel $LN23+426
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091c01H
	DD	018741cH
	DD	017641cH
	DD	016341cH
	DD	014011cH
	DD	05010H
; Function compile flags: /Ogtpy
; File c:\users\lenovo\downloads\zlib-1.2.11\contrib\masmx64\inffas8664.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
ar$ = 32
strm$ = 176
start$ = 184
inflate_fast PROC					; COMDAT

; 109  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 110  :     struct inflate_state FAR *state;
; 111  :     type_ar ar;
; 112  :     void inffas8664fnc(struct inffast_ar * par);
; 113  : 
; 114  : 
; 115  : 
; 116  : #if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
; 117  : #define PAD_AVAIL_IN 6
; 118  : #define PAD_AVAIL_OUT 258
; 119  : #else
; 120  : #define PAD_AVAIL_IN 5
; 121  : #define PAD_AVAIL_OUT 257
; 122  : #endif
; 123  : 
; 124  :     /* copy state to local variables */
; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001c	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  00020	48 8b d9	 mov	 rbx, rcx

; 126  : 
; 127  :     ar.in = strm->next_in;

  00023	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00026	8b c2		 mov	 eax, edx

; 128  :     ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);

  00028	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]

; 129  :     ar.out = strm->next_out;
; 130  :     ar.beg = ar.out - (start - strm->avail_out);
; 131  :     ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
; 132  :     ar.wsize = state->wsize;
; 133  :     ar.write = state->wnext;
; 134  :     ar.window = state->window;
; 135  :     ar.hold = state->hold;
; 136  :     ar.bits = state->bits;
; 137  :     ar.lcode = state->lencode;
; 138  :     ar.dcode = state->distcode;
; 139  :     ar.lmask = (1U << state->lenbits) - 1;

  0002c	be 01 00 00 00	 mov	 esi, 1
  00031	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00034	41 83 e8 06	 sub	 r8d, 6
  00038	2b c2		 sub	 eax, edx
  0003a	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10
  0003e	4d 03 c2	 add	 r8, r10
  00041	4c 89 45 ef	 mov	 QWORD PTR ar$[rbp-49], r8
  00045	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00049	4c 89 45 f7	 mov	 QWORD PTR ar$[rbp-41], r8
  0004d	49 8b c8	 mov	 rcx, r8
  00050	48 2b c8	 sub	 rcx, rax
  00053	48 89 4d ff	 mov	 QWORD PTR ar$[rbp-33], rcx
  00057	8d 8a fe fe ff
	ff		 lea	 ecx, DWORD PTR [rdx-258]
  0005d	49 03 c8	 add	 rcx, r8
  00060	48 89 4d 07	 mov	 QWORD PTR ar$[rbp-25], rcx
  00064	8b 47 34	 mov	 eax, DWORD PTR [rdi+52]
  00067	89 45 33	 mov	 DWORD PTR ar$[rbp+19], eax
  0006a	8b 47 3c	 mov	 eax, DWORD PTR [rdi+60]
  0006d	89 45 37	 mov	 DWORD PTR ar$[rbp+23], eax
  00070	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  00074	48 89 45 0f	 mov	 QWORD PTR ar$[rbp-17], rax
  00078	44 8b 47 48	 mov	 r8d, DWORD PTR [rdi+72]
  0007c	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  00080	8b 57 4c	 mov	 edx, DWORD PTR [rdi+76]
  00083	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  00086	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0008a	48 89 45 17	 mov	 QWORD PTR ar$[rbp-9], rax
  0008e	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  00092	48 89 45 1f	 mov	 QWORD PTR ar$[rbp-1], rax
  00096	8b c6		 mov	 eax, esi
  00098	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  0009b	d3 e0		 shl	 eax, cl
  0009d	ff c8		 dec	 eax
  0009f	89 45 3b	 mov	 DWORD PTR ar$[rbp+27], eax

; 140  :     ar.dmask = (1U << state->distbits) - 1;

  000a2	8b c6		 mov	 eax, esi
  000a4	8b 4f 74	 mov	 ecx, DWORD PTR [rdi+116]
  000a7	d3 e0		 shl	 eax, cl
  000a9	ff c8		 dec	 eax
  000ab	89 45 3f	 mov	 DWORD PTR ar$[rbp+31], eax

; 141  : 
; 142  :     /* decode literals and length/distances until end-of-block or not enough
; 143  :        input data or output space */
; 144  : 
; 145  :     /* align in on 1/2 hold size boundary */
; 146  :     while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {

  000ae	41 f6 c2 03	 test	 r10b, 3
  000b2	74 2e		 je	 SHORT $LN3@inflate_fa
  000b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@inflate_fa:

; 147  :         ar.hold += (unsigned long)*ar.in++ << ar.bits;

  000c0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000c4	8b ca		 mov	 ecx, edx
  000c6	d3 e0		 shl	 eax, cl
  000c8	49 ff c2	 inc	 r10
  000cb	4c 03 c0	 add	 r8, rax
  000ce	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10

; 148  :         ar.bits += 8;

  000d2	83 c2 08	 add	 edx, 8
  000d5	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  000d9	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  000dc	41 f6 c2 03	 test	 r10b, 3
  000e0	75 de		 jne	 SHORT $LL2@inflate_fa
$LN3@inflate_fa:

; 149  :     }
; 150  : 
; 151  :     inffas8664fnc(&ar);

  000e2	48 8d 4d d7	 lea	 rcx, QWORD PTR ar$[rbp-73]
  000e6	e8 00 00 00 00	 call	 inffas8664fnc

; 152  : 
; 153  :     if (ar.status > 1) {

  000eb	8b 4d 4b	 mov	 ecx, DWORD PTR ar$[rbp+43]
  000ee	3b ce		 cmp	 ecx, esi
  000f0	76 3b		 jbe	 SHORT $LN20@inflate_fa

; 154  :         if (ar.status == 2)

  000f2	83 f9 02	 cmp	 ecx, 2
  000f5	75 14		 jne	 SHORT $LN6@inflate_fa

; 155  :             strm->msg = "invalid literal/length code";

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 156  :         else if (ar.status == 3)

  000fe	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  00102	c7 47 08 51 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16209 ; 00003f51H

; 161  :     }

  00109	eb 2b		 jmp	 SHORT $LN10@inflate_fa
$LN6@inflate_fa:

; 156  :         else if (ar.status == 3)

  0010b	83 f9 03	 cmp	 ecx, 3
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0011c	48 0f 45 c2	 cmovne	 rax, rdx
  00120	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  00124	c7 47 08 51 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16209 ; 00003f51H

; 161  :     }

  0012b	eb 09		 jmp	 SHORT $LN10@inflate_fa
$LN20@inflate_fa:

; 162  :     else if ( ar.status == 1 ) {

  0012d	75 07		 jne	 SHORT $LN10@inflate_fa

; 163  :         state->mode = TYPE;

  0012f	c7 47 08 3f 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16191 ; 00003f3fH
$LN10@inflate_fa:

; 164  :     }
; 165  : 
; 166  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 167  :     ar.len = ar.bits >> 3;

  00136	8b 4d 2f	 mov	 ecx, DWORD PTR ar$[rbp+15]

; 168  :     ar.in -= ar.len;
; 169  :     ar.bits -= ar.len << 3;
; 170  :     ar.hold &= (1U << ar.bits) - 1;
; 171  : 
; 172  :     /* update state and return */
; 173  :     strm->next_in = ar.in;
; 174  :     strm->next_out = ar.out;
; 175  :     strm->avail_in = (unsigned)(ar.in < ar.last ?
; 176  :                                 PAD_AVAIL_IN + (ar.last - ar.in) :
; 177  :                                 PAD_AVAIL_IN - (ar.in - ar.last));
; 178  :     strm->avail_out = (unsigned)(ar.out < ar.end ?
; 179  :                                  PAD_AVAIL_OUT + (ar.end - ar.out) :
; 180  :                                  PAD_AVAIL_OUT - (ar.out - ar.end));
; 181  :     state->hold = (unsigned long)ar.hold;
; 182  :     state->bits = ar.bits;
; 183  :     return;
; 184  : }

  00139	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00141	4c 8b 45 e7	 mov	 r8, QWORD PTR ar$[rbp-57]
  00145	8b d1		 mov	 edx, ecx
  00147	c1 ea 03	 shr	 edx, 3
  0014a	8b c2		 mov	 eax, edx
  0014c	4c 2b c0	 sub	 r8, rax
  0014f	4c 89 03	 mov	 QWORD PTR [rbx], r8
  00152	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [rdx*8]
  00159	2b c8		 sub	 ecx, eax
  0015b	d3 e6		 shl	 esi, cl
  0015d	89 4d 2f	 mov	 DWORD PTR ar$[rbp+15], ecx
  00160	48 8b 4d f7	 mov	 rcx, QWORD PTR ar$[rbp-41]
  00164	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  00168	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  0016b	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0016f	48 21 45 27	 and	 QWORD PTR ar$[rbp+7], rax
  00173	48 8b 45 ef	 mov	 rax, QWORD PTR ar$[rbp-49]
  00177	49 2b c0	 sub	 rax, r8
  0017a	48 83 c0 06	 add	 rax, 6
  0017e	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00181	48 8b 45 07	 mov	 rax, QWORD PTR ar$[rbp-25]
  00185	48 2b c1	 sub	 rax, rcx
  00188	48 05 02 01 00
	00		 add	 rax, 258		; 00000102H
  0018e	89 43 18	 mov	 DWORD PTR [rbx+24], eax
  00191	8b 45 27	 mov	 eax, DWORD PTR ar$[rbp+7]
  00194	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00198	89 47 48	 mov	 DWORD PTR [rdi+72], eax
  0019b	8b 45 2f	 mov	 eax, DWORD PTR ar$[rbp+15]
  0019e	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
  001a1	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  001a5	49 8b e3	 mov	 rsp, r11
  001a8	5d		 pop	 rbp
  001a9	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
